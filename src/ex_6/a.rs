use super::super::files;

const N: u32 = 18;

pub fn run() {
    // first we read the raw lines from the input file
    let raw_lines = files::get_lines(String::from(
        "/Users/rama/Documents/adventofcode/2021/rust/src/ex_6/example.txt",
    ));

    let values: Vec<u32> = raw_lines[0].split(',').map(|x| x.parse().unwrap()).map(|x: u32| x+1).collect();

    // 3,4,3,1,2
    // lets say i want to calculate the state after N = 5 days.
    // lets add all of these 5
    // 8, 9, 8, 6, 7
    // let's divide by 6, and get the remainder
    // 1 (2), 1 (3), 1 (2), 1 (0), 1 (1)
    // the remainder gives us the current state of the original fish.
    // the quotient gives us the # of fish generated by those initial fishes.
    // new fishes are initialized with a value of 8, which means they have an offset of 2, with regard to the fish..a

    // let's think with the actual N = 18.
    // 3,4,3,1,2
    // let's sum 18
    // 21, 22, 21, 19, 20
    // let's apply mod 7,
    // 3 (0), 3 (1), 3(0), 2 (5), 2 (6)
    // with the exercise notation:
    // 6, 0, 6, 5+6 % 7 = 4, 5
    // so we can have the finishing states of our initial fish, and how many fishes those fishes created..
    // we know there are 13 new fishes by day 18, CREATED by the original fishes. Those new fishes might have created more by themselves

    // 3,4,3,1,2 
    // how long until we reach 7 for one of them?
    // it's easier to think these as negative numbers.. and to add -1, to make them work like real (not clowny) numbers..
    // -4, -5, -4, -2, -3
    // soo +2?
    // -2, -3, -2, 0, -1 -> here we introduce a new fish on -9
    // -2, -3, -2, 0, -1, -9
    // up next? +1
    // -1, -2, -1, 1 (or -6), 0, -8 -> here we introduce a new fish on -9
    // -1, -2, -1, -6, 0, -8, -9

    // i think we can think of ALL fishes as starting in -9 at different offsets, and then going mod 7.
    // so the original:
    // -4, -5, -4, -2, -3
    // are actually the offsets,
    // +5, +4, +5, +7, +6
    // the relatives offsets (-4) are:
    // +1, 0, +1, +3, +2
    // soo.. i guess i can calculate them all at the same time, and the apply the offset?
    // like.. for example, if the were 5 fishes starting at -9, it would take them 9 days to create 10 fishes...
    // so.. at day 9 there would be 10 fishes. BUT..
    // then we apply the offset:
    // (day 9+1), (day 9+0), (day 9+1), (day 9+3), (day 9+2)
    // well... this is not correct because the 4th should happen first, but i think i'm into something here.

    // 3,4,3,1,2 
    // applying +1
    // 4,5,4,2,3 are the offsets.. 
    // 2,3,2,0,1 are the relative offsets (-2)
    // so the actual problem is... given N arbitrary fishes and the initial offsets of a few, what are the actual offsets for each fish?
    // 2,3,2,0,1,9 (with the new fish)
    // a way is to add 9 to all existing fishes
    // 2,3,2,0,1,2+9,3+9,2+9,0+9,1+9
    // meaning...
    // 2,3,2,0,1,11,12,11,9,10
    // let's add 9 one more time to see what happens.
    // 2,3,2,0,1,11,12,11,9,10,11,12,11,9,10,11+9,12+9,11+9,9+9,10+9
    // meaning...
    // 2,3,2,0,1,11,12,11,9,10,11,12,11,9,10,20,21,20,18,19

    // i think there's something wrong with that thinking...
    // we start with 5 fish...
    // let's imagine then that we have
    // 0,0,0,0,0,9,9,9,9,9
    // meaning we are at the point where they all have children, modulo the offsets
    // relative: 2,3,2,0,1, absolute: 4,5,4,2,3
    // the next state is 7 days later:
    // 0,0,0,0,0,2,2,2,2,2,9,9,9,9,9
    // the next state is 2 days later:
    // 5,5,5,5,5,0,0,0,0,0,7,7,7,7,7,9,9,9,9,9
    // the next state is 5 days later:
    // 0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,9,9,9,9,9
    // the next state is 2 days later:
    // 5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,7,7,7,7,7,9,9,9,9,9,9,9,9,9,9
    // apply the original offsets in that order
    // 5+4,5+5,5+4,5+2,5+3,0+4,0+5...
    // 9,10,9,7,8,4,5,4,2,3,6,7,6,4,5,11,12,11,9,10,13,14,13,11,12,13,14,13,11,12
    // now we... what do we do?
    // i guess... any number bigger than 7+offset is dropped?
    // 9,10,9,7,8,4,5,4,2,3,6,7,6,4,5,11,12,11,9,10,13
    // let's just subtract 3...
    // 6,7,6,4,5,1,2,1,6,0,3,4,3,1,2,8,9,8,6,7,10
    // 6,0,6,4,5,6,0,1,1,2,6,0,1,1,1,2,2,3,3,4,6,7,8,8,8,8


    // 3,4,3,1,2
    // +1
    // 4,5,4,2,3,9+4,9+5,9+4,9+2,9+3,9+4+7,9+5+7,9+4+7,9+2+7,9+3+7
    // 4,5,4,2,3,13, 14, 13, 11, 12,  20,   21,   20     18   19 
    // 4,5,4,2,3,13, 14, 13, 11, 12,  20,   21,   20     18   19 , 9+4+9, 9+5+9, 9+4+9, 9+2+9, 9+3+9 (this are the new fishes' children)
    // 4,5,4,2,3,13, 14, 13, 11, 12,  20,   21,   20     18   19 ,   22,    23,   22  ,   20,   21
    // then we have to "cut"

    // so we have terms of the form:
    // 4,5,4,2,3 -> original
    // a+9 -> original's children
    // a+9+7x -> original's every possible children
    // a+9y -> original's children's children
    // a+9x+7y -> every possible value (descendant x, on iteration y)
    // we have to find all solutions that are < N+9

    // i fell again in he pitfall... remember, smaller numbers wrap first!!


    // let values:Vec<u32> = vec![4,5,4,2,3]; // remember, these are offsets!
    let max = values.iter().max().unwrap();
    let border = N + 9 + 1; // what's exactly the border condition?
    let mut solutions:Vec<u32> = vec![];
    let mut count: u32 = 0;
    for x in 0..border {
        for y in 0..border {
            if x == 0 && y != 0 {
                continue;
            }

            // there are "movement terms" and an "offset" term. that's how we'll fix this issue.
            // so, the yeah, the issue is there are 2 ways to generate different fishes..
            // and yet the equation only encodes one. we have to find a way to encode the creation
            // differently.
            // 2 + 7 + 9 + 9 -> this one is lost
            // 2 + 9 + 9 + 7 -> this one exists

            // 4,5,4,2,3
            // 4,5,4,2,3 + 9,9,9,9,9 (offsets)
            // 4,5,4,2,3 + 7,7,7,7,7 (displacement) + 9,9,9,9,9 (offsets)

            // this are the generated values, with the missing fish
            // value: 4, x: 0, y: 0, solution: 4
            // value: 5, x: 0, y: 0, solution: 5
            // value: 4, x: 0, y: 0, solution: 4
            // value: 2, x: 0, y: 0, solution: 2
            // value: 3, x: 0, y: 0, solution: 3
            // value: 4, x: 1, y: 0, solution: 13
            // value: 5, x: 1, y: 0, solution: 14
            // value: 4, x: 1, y: 0, solution: 13
            // value: 2, x: 1, y: 0, solution: 11
            // value: 3, x: 1, y: 0, solution: 12
            // value: 4, x: 1, y: 1, solution: 20
            // value: 5, x: 1, y: 1, solution: 21
            // value: 4, x: 1, y: 1, solution: 20
            // value: 2, x: 1, y: 1, solution: 18
            // value: 3, x: 1, y: 1, solution: 19
            // value: 4, x: 1, y: 2, solution: 27
            // value: 4, x: 1, y: 2, solution: 27
            // value: 2, x: 1, y: 2, solution: 25
            // value: 3, x: 1, y: 2, solution: 26
            // value: 4, x: 2, y: 0, solution: 22
            // value: 5, x: 2, y: 0, solution: 23
            // value: 4, x: 2, y: 0, solution: 22
            // value: 2, x: 2, y: 0, solution: 20
            // value: 3, x: 2, y: 0, solution: 21
            // value: 2, x: 2, y: 1, solution: 27

            for value in values.iter() {
                let solution = value + 9 * x + 7 * y;
                if solution < border {
                    println!("value: {}, x: {}, y: {}, solution: {}", value, x, y, solution);
                    solutions.push(solution);
                    count += 1;
                }
            }
        }
    }

    println!("count: {}, solutions: {:?}", count, solutions);

}